{
  "id": 2905,
  "date": "2015-10-25T07:22:25",
  "date_gmt": "2015-10-25T07:22:25",
  "guid": {
    "rendered": "http://ronvalstar.nl/?p=2905"
  },
  "modified": "2017-01-14T13:30:03",
  "modified_gmt": "2017-01-14T13:30:03",
  "slug": "experiment-blob",
  "status": "publish",
  "type": "post",
  "link": "https://ronvalstar.nl/experiment-blob",
  "title": {
    "rendered": "Experiment: webgl blob"
  },
  "content": {
    "rendered": "<p>This is an experiment with WebGL shaders. The Javascript code is nothing much; just a scaffold to load GLSL scripts, run the shader program and some events to parse mouse- and keyboard input. The cool bit is the shader code itself.<br />\n<!--more--></p>\n<p>WebGL shaders are written in GLSL, a C-like language. This takes some getting used to if you&#8217;ve only coded Javascript. Functions and variables aren&#8217;t hoisted: you have to declare methods and variables before you use them. GLSL is typed, so you have to explicitly declare the type of variables, parameters and return values. And since the GLSL code is parsed to the canvas as one string this will result in extremely long files that end with the main method.</p>\n<p>This sucks a bit, even normal C has directive called #include which, well, it includes bits and pieces. But GLSL is parsed  as a string before interpretation, so we can do stuff. If you&#8217;ve used Javascript, probably you&#8217;ve used Grunt, and possibly you&#8217;ve written build scripts. Which is what I&#8217;ve done here <small>(sort of)</small>: loaded the GLSL script, search it for #include references, load and include them&#8230; and finally parse the GLSL script.</p>\n<p>The shader technique used is called raycasting. I won&#8217;t elaborate on the technical details but the result is a space where objects no longer have to be defined by vertices and polygons but by &#8216;simple&#8217; formulae. A sphere is a point in space with a radius. This means naturally smooth objects.</p>\n<p>My first go at this is quite simple really; a distance to the y axis to create an infinite horizontal cavern, a sphere modulated over a distance on the x and z axis to populate the cavern with pillars, and a 3-D simplex noise moving downward along the y-axis. Rules are multiplied rather than added so the pillars seem embedded into the cave and the ceiling seems to be dripping. And the same noise field to add some colour.</p>\n<pre><code data-language=\"javascript\" data-src=\"/wordpress/wp-content/themes/sjeiti/static/experiment/blob.js\"></code></pre>\n<pre><code data-language=\"glsl\" data-src=\"/wordpress/wp-content/themes/sjeiti/static/glsl/blob.glsl\"></code></pre>\n",
    "protected": false
  },
  "excerpt": {
    "rendered": "<p>This is an experiment with WebGL shaders. The Javascript code is nothing much; just a scaffold to load GLSL scripts, run the shader program and some events to parse mouse- and keyboard input. The cool bit is the shader code itself.</p>\n",
    "protected": false
  },
  "author": 2,
  "featured_media": 2922,
  "comment_status": "open",
  "ping_status": "open",
  "sticky": false,
  "template": "",
  "format": "standard",
  "meta": [],
  "categories": [
    5,
    13
  ],
  "tags": [
    297
  ],
  "terms": {
    "post_tag": [
      {
        "term_id": 297,
        "name": "webgl",
        "slug": "webgl",
        "term_group": 0,
        "term_taxonomy_id": 301,
        "taxonomy": "post_tag",
        "description": "",
        "parent": 0,
        "count": 6,
        "filter": "raw",
        "term_order": "0",
        "ID": 297
      }
    ],
    "category": [
      {
        "term_id": 5,
        "name": "code",
        "slug": "code",
        "term_group": 0,
        "term_taxonomy_id": 5,
        "taxonomy": "category",
        "description": "",
        "parent": 170,
        "count": 71,
        "filter": "raw",
        "term_order": "0",
        "ID": 5
      },
      {
        "term_id": 13,
        "name": "Javascript",
        "slug": "javascript",
        "term_group": 0,
        "term_taxonomy_id": 13,
        "taxonomy": "category",
        "description": "",
        "parent": 5,
        "count": 52,
        "filter": "raw",
        "term_order": "0",
        "ID": 13
      }
    ]
  },
  "_links": {
    "self": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/posts/2905"
      }
    ],
    "collection": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/posts"
      }
    ],
    "about": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/types/post"
      }
    ],
    "author": [
      {
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/users/2"
      }
    ],
    "replies": [
      {
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/comments?post=2905"
      }
    ],
    "version-history": [
      {
        "count": 13,
        "href": "https://ronvalstar.nl/api/wp/v2/posts/2905/revisions"
      }
    ],
    "predecessor-version": [
      {
        "id": 3279,
        "href": "https://ronvalstar.nl/api/wp/v2/posts/2905/revisions/3279"
      }
    ],
    "wp:featuredmedia": [
      {
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/media/2922"
      }
    ],
    "wp:attachment": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/media?parent=2905"
      }
    ],
    "wp:term": [
      {
        "taxonomy": "category",
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/categories?post=2905"
      },
      {
        "taxonomy": "post_tag",
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/tags?post=2905"
      }
    ],
    "curies": [
      {
        "name": "wp",
        "href": "https://api.w.org/{rel}",
        "templated": true
      }
    ]
  }
}